//! BlueDriver OBD-II log file parser.
//!
//! Parses CSV log files generated by BlueDriver OBD-II scan tool app.
//! Format:
//! - Line 1: "BlueDriver Data Log" (title)
//! - Line 2: Date (e.g., "Jan 16, 2026")
//! - Line 3: Header with channel names and units in parentheses
//! - Lines 4+: Data rows with comma-separated values
//! - Time column is in decimal seconds
//!
//! Files are typically UTF-16 encoded with BOM marker.
//!
//! Reference: <https://www.bluedriver.com/>

use serde::Serialize;
use std::error::Error;

use super::types::{Channel, Log, Meta, Parseable, Value};

/// BlueDriver log file metadata
#[derive(Clone, Debug, Default, Serialize)]
pub struct BlueDriverMeta {
    /// Date from the second line of the file
    pub date: String,
    /// Number of channels in the log
    pub channel_count: usize,
    /// Number of data points
    pub data_points: usize,
}

/// BlueDriver channel definition
#[derive(Clone, Debug, Default, Serialize)]
pub struct BlueDriverChannel {
    /// Full column name from header (e.g., "Engine RPM (rpm)")
    pub name: String,
    /// Extracted unit from parentheses (e.g., "rpm")
    pub unit: String,
}

impl BlueDriverChannel {
    /// Create a new channel from a header column name
    /// Parses names like "Engine RPM (rpm)" into name and unit
    pub fn from_header(header: &str) -> Self {
        let header = header.trim().to_string();

        // Try to extract unit from parentheses at end
        // Format: "Channel Name (unit)" or "Channel Name"
        let (name, unit) = if let Some(paren_start) = header.rfind('(') {
            if let Some(paren_end) = header.rfind(')') {
                if paren_end > paren_start {
                    let unit = header[paren_start + 1..paren_end].trim().to_string();
                    let name = header[..paren_start].trim().to_string();
                    (name, unit)
                } else {
                    (header.clone(), String::new())
                }
            } else {
                (header.clone(), String::new())
            }
        } else {
            (header.clone(), String::new())
        };

        Self { name, unit }
    }
}

/// BlueDriver log file parser
pub struct BlueDriver;

impl BlueDriver {
    /// Detect if content is a BlueDriver log file
    /// BlueDriver files start with "BlueDriver Data Log" (possibly with UTF-16 BOM)
    pub fn detect(contents: &str) -> bool {
        if let Some(first_line) = contents.lines().next() {
            let first_line_trimmed = first_line.trim();
            // Check for BlueDriver title marker
            if first_line_trimmed.contains("BlueDriver") && first_line_trimmed.contains("Data Log")
            {
                return true;
            }
        }
        false
    }
}

impl Parseable for BlueDriver {
    fn parse(&self, file_contents: &str) -> Result<Log, Box<dyn Error>> {
        let mut lines = file_contents.lines();

        // Line 1: Title (skip)
        let title = lines
            .next()
            .ok_or("Empty file: expected BlueDriver title")?;
        if !title.contains("BlueDriver") {
            return Err("Invalid BlueDriver format: first line should contain 'BlueDriver'".into());
        }

        // Line 2: Date
        let date = lines.next().ok_or("Missing date line")?.trim().to_string();

        // Line 3: Header with channel names
        let header = lines.next().ok_or("Missing header line")?;

        // Parse header to get channel names and units
        let header_parts: Vec<&str> = header.split(',').collect();
        if header_parts.is_empty() {
            return Err("Header line is empty".into());
        }

        // First column should be Time
        let time_header = header_parts[0].trim();
        if !time_header.to_lowercase().starts_with("time") {
            return Err(format!("Expected Time as first column, found: {}", time_header).into());
        }

        // Parse remaining columns as channels
        let channels: Vec<Channel> = header_parts[1..]
            .iter()
            .map(|h| Channel::BlueDriver(BlueDriverChannel::from_header(h)))
            .collect();

        let channel_count = channels.len();
        if channel_count == 0 {
            return Err("No channels found in header".into());
        }

        // Parse data rows
        let mut times: Vec<f64> = Vec::new();
        let mut data: Vec<Vec<Value>> = Vec::new();

        for line in lines {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split(',').collect();
            if parts.is_empty() {
                continue;
            }

            // First column is time in seconds
            let time_str = parts[0].trim();
            let time: f64 = match time_str.parse() {
                Ok(t) => t,
                Err(_) => continue, // Skip rows with invalid time
            };

            // Parse remaining values
            let mut row_values: Vec<Value> = Vec::with_capacity(channel_count);
            for val_str in parts[1..].iter() {
                let val_str = val_str.trim();
                if val_str.is_empty() {
                    // Empty value - use NaN to represent missing data
                    row_values.push(Value::Float(f64::NAN));
                } else {
                    match val_str.parse::<f64>() {
                        Ok(v) => row_values.push(Value::Float(v)),
                        Err(_) => row_values.push(Value::Float(f64::NAN)),
                    }
                }
            }

            // Only add row if we have the expected number of values
            if row_values.len() >= channel_count {
                times.push(time);
                // Truncate to expected channel count
                row_values.truncate(channel_count);
                data.push(row_values);
            }
        }

        let data_points = times.len();

        // Create metadata
        let meta = Meta::BlueDriver(BlueDriverMeta {
            date,
            channel_count,
            data_points,
        });

        tracing::info!(
            "BlueDriver parse complete: {} channels, {} data points",
            channel_count,
            data_points
        );

        Ok(Log {
            channels,
            times,
            data,
            meta,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_bluedriver() {
        let content = "BlueDriver Data Log\nJan 16, 2026\nTime(s), Engine RPM (rpm)\n";
        assert!(BlueDriver::detect(content));
    }

    #[test]
    fn test_channel_from_header() {
        let channel = BlueDriverChannel::from_header("Engine RPM (rpm)");
        assert_eq!(channel.name, "Engine RPM");
        assert_eq!(channel.unit, "rpm");

        let channel2 =
            BlueDriverChannel::from_header("O2 Bank 1 - Sensor 2 - Oxygen Sensor Voltage (V)");
        assert_eq!(
            channel2.name,
            "O2 Bank 1 - Sensor 2 - Oxygen Sensor Voltage"
        );
        assert_eq!(channel2.unit, "V");
    }

    #[test]
    fn test_parse_bluedriver() {
        let content = "BlueDriver Data Log\n\
                       Jan 16, 2026\n\
                       Time(s), Engine RPM (rpm), Voltage (V)\n\
                       0.00, 850, 14.2\n\
                       0.50, 900, 14.1\n\
                       1.00, 950, 14.0\n";

        let parser = BlueDriver;
        let log = parser.parse(content).expect("Parse failed");

        assert_eq!(log.channels.len(), 2);
        assert_eq!(log.times.len(), 3);
        assert_eq!(log.data.len(), 3);

        if let Meta::BlueDriver(meta) = log.meta {
            assert_eq!(meta.date, "Jan 16, 2026");
            assert_eq!(meta.channel_count, 2);
            assert_eq!(meta.data_points, 3);
        } else {
            panic!("Expected BlueDriver metadata");
        }
    }
}
