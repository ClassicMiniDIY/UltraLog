//! RomRaider log file parser.
//!
//! Parses CSV log files generated by RomRaider ECU logging software,
//! commonly used for Subaru ECUs. Format is comma-delimited CSV with
//! channel names and units in the header row.
//!
//! Reference: <https://github.com/RomRaider/RomRaider>

use serde::Serialize;
use std::error::Error;

use super::types::{Channel, Log, Meta, Parseable, Value};

/// RomRaider log file metadata
#[derive(Clone, Debug, Default, Serialize)]
pub struct RomRaiderMeta {
    /// Number of channels in the log
    pub channel_count: usize,
    /// Number of data points
    pub data_points: usize,
}

/// RomRaider channel definition
#[derive(Clone, Debug, Default, Serialize)]
pub struct RomRaiderChannel {
    /// Full column name from header (e.g., "Engine Speed (rpm)")
    pub name: String,
    /// Extracted unit from parentheses (e.g., "rpm")
    pub unit: String,
}

impl RomRaiderChannel {
    /// Create a new channel from a header column name
    /// Parses names like "Engine Speed (rpm)" into name and unit
    pub fn from_header(header: &str) -> Self {
        let header = header.trim().to_string();

        // Try to extract unit from parentheses at end
        // Format: "Channel Name (unit)" or "Channel Name"
        let (name, unit) = if let Some(paren_start) = header.rfind('(') {
            if let Some(paren_end) = header.rfind(')') {
                if paren_end > paren_start {
                    let unit = header[paren_start + 1..paren_end].trim().to_string();
                    let name = header[..paren_start].trim().to_string();
                    (name, unit)
                } else {
                    (header.clone(), Self::infer_unit(&header))
                }
            } else {
                (header.clone(), Self::infer_unit(&header))
            }
        } else {
            (header.clone(), Self::infer_unit(&header))
        };

        Self { name, unit }
    }

    /// Infer unit based on channel name when not explicitly provided
    fn infer_unit(name: &str) -> String {
        let name_lower = name.to_lowercase();

        // Temperature channels
        if name_lower.contains("temp") || name_lower.contains("iat") || name_lower.contains("ect") {
            return "°C".to_string();
        }

        // Pressure channels
        if name_lower.contains("pressure")
            || name_lower.contains("map")
            || name_lower.contains("baro")
            || name_lower.contains("boost")
        {
            return "psi".to_string();
        }

        // RPM channels
        if name_lower.contains("rpm") || name_lower.contains("engine speed") {
            return "rpm".to_string();
        }

        // Throttle/TPS channels
        if name_lower.contains("tps") || name_lower.contains("throttle") {
            return "%".to_string();
        }

        // Percentage channels
        if name_lower.contains("duty")
            || name_lower.contains("correction")
            || name_lower.contains("learning")
            || name_lower.contains("load")
        {
            return "%".to_string();
        }

        // Timing/angle channels
        if name_lower.contains("timing")
            || name_lower.contains("angle")
            || name_lower.contains("knock")
            || name_lower.contains("degrees")
        {
            return "°".to_string();
        }

        // Voltage channels
        if name_lower.contains("voltage") || name_lower.contains("battery") {
            return "V".to_string();
        }

        // AFR/Lambda channels
        if name_lower.contains("afr") || name_lower.contains("a/f") {
            return "AFR".to_string();
        }

        // Speed channels
        if name_lower.contains("speed") && !name_lower.contains("rpm") {
            return "mph".to_string();
        }

        // Mass airflow
        if name_lower.contains("maf") || name_lower.contains("mass airflow") {
            return "g/s".to_string();
        }

        // IAM (Ignition Advance Multiplier) - Subaru specific
        if name_lower == "iam" {
            return "".to_string();
        }

        // Default: no unit
        "".to_string()
    }

    /// Get the display unit for this channel
    pub fn unit(&self) -> &str {
        &self.unit
    }
}

/// RomRaider log file parser
pub struct RomRaider;

impl RomRaider {
    /// Detect if file contents look like a RomRaider log
    /// RomRaider logs are comma-delimited and typically start with "Time"
    pub fn detect(contents: &str) -> bool {
        if let Some(first_line) = contents.lines().next() {
            let first_line_lower = first_line.to_lowercase();

            // Must be comma-delimited
            if !first_line.contains(',') {
                return false;
            }

            // RomRaider logs typically start with Time column
            // Common patterns: "Time", "Time (msec)", "Time(ms)", etc.
            if first_line_lower.starts_with("time") {
                // Exclude other formats that also use "time" column
                // ECUMaster uses semicolon delimiter
                if first_line.contains(';') {
                    return false;
                }

                // Haltech uses "%DataLog%" marker or specific metadata format
                // Additional checks can be added here

                return true;
            }
        }
        false
    }

    /// Parse time value from milliseconds string to seconds
    fn parse_time_ms(time_str: &str) -> Option<f64> {
        time_str.trim().parse::<f64>().ok().map(|ms| ms / 1000.0)
    }
}

impl Parseable for RomRaider {
    fn parse(&self, file_contents: &str) -> Result<Log, Box<dyn Error>> {
        // Pre-allocate based on estimated row count (first line is header)
        let line_count = file_contents.lines().count();
        let estimated_data_rows = line_count.saturating_sub(1);

        let mut channels: Vec<Channel> = Vec::with_capacity(50);
        let mut times: Vec<f64> = Vec::with_capacity(estimated_data_rows);
        let mut data: Vec<Vec<Value>> = Vec::with_capacity(estimated_data_rows);

        let mut lines = file_contents.lines();

        // Parse header line to get channel names
        let header = lines.next().ok_or("Empty file: no header found")?;

        let column_names: Vec<&str> = header.split(',').collect();

        if column_names.is_empty() {
            return Err("Invalid RomRaider log: no columns found".into());
        }

        // First column should be Time
        let first_col = column_names[0].trim().to_lowercase();
        if !first_col.starts_with("time") {
            return Err("Invalid RomRaider log: first column must be Time".into());
        }

        // Create channels from header (skip Time column)
        for name in column_names.iter().skip(1) {
            let channel = RomRaiderChannel::from_header(name);
            channels.push(Channel::RomRaider(channel));
        }

        // Track first timestamp for relative time calculation
        let mut first_time: Option<f64> = None;

        // Parse data rows
        for line in lines {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split(',').collect();
            if parts.is_empty() {
                continue;
            }

            // First column is time (in milliseconds)
            let time_str = parts[0].trim();
            if let Some(time_secs) = Self::parse_time_ms(time_str) {
                // Calculate relative time from first record
                let relative_time = if let Some(first) = first_time {
                    time_secs - first
                } else {
                    first_time = Some(time_secs);
                    0.0
                };

                times.push(relative_time);

                // Parse remaining values
                let mut row_values: Vec<Value> = Vec::with_capacity(channels.len());

                for part in parts.iter().skip(1) {
                    let part = part.trim();

                    if part.is_empty() {
                        // Empty value - use 0
                        row_values.push(Value::Float(0.0));
                    } else if let Ok(val) = part.parse::<f64>() {
                        row_values.push(Value::Float(val));
                    } else {
                        // Non-numeric value - use 0
                        row_values.push(Value::Float(0.0));
                    }
                }

                // Pad row to match channel count if needed
                while row_values.len() < channels.len() {
                    row_values.push(Value::Float(0.0));
                }

                data.push(row_values);
            }
        }

        tracing::info!(
            "Parsed RomRaider log: {} channels, {} data points",
            channels.len(),
            data.len()
        );

        Ok(Log {
            meta: Meta::RomRaider(RomRaiderMeta {
                channel_count: channels.len(),
                data_points: data.len(),
            }),
            channels,
            times,
            data,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_channel_from_header() {
        let ch = RomRaiderChannel::from_header("Engine Speed (rpm)");
        assert_eq!(ch.name, "Engine Speed");
        assert_eq!(ch.unit, "rpm");

        let ch = RomRaiderChannel::from_header("A/F Correction #1 (%)");
        assert_eq!(ch.name, "A/F Correction #1");
        assert_eq!(ch.unit, "%");

        let ch = RomRaiderChannel::from_header("IAM");
        assert_eq!(ch.name, "IAM");
        assert_eq!(ch.unit, "");

        let ch = RomRaiderChannel::from_header("Manifold Relative Pressure (psi)");
        assert_eq!(ch.name, "Manifold Relative Pressure");
        assert_eq!(ch.unit, "psi");
    }

    #[test]
    fn test_unit_inference() {
        assert_eq!(RomRaiderChannel::infer_unit("Coolant Temp"), "°C");
        assert_eq!(RomRaiderChannel::infer_unit("Engine Speed"), "rpm");
        assert_eq!(RomRaiderChannel::infer_unit("Throttle Opening Angle"), "%");
        assert_eq!(RomRaiderChannel::infer_unit("Battery Voltage"), "V");
        assert_eq!(RomRaiderChannel::infer_unit("A/F Sensor #1"), "AFR");
        assert_eq!(RomRaiderChannel::infer_unit("Mass Airflow"), "g/s");
    }

    #[test]
    fn test_detect_romraider() {
        // Should detect RomRaider format
        assert!(RomRaider::detect(
            "Time (msec),Engine Speed (rpm),Engine Load (%)\n0,1000,50"
        ));
        assert!(RomRaider::detect("Time,RPM,Load\n0,1000,50"));

        // Should not detect other formats
        assert!(!RomRaider::detect(
            "TIME;engine/rpm;sensors/tps\n0.000;1000;50"
        ));
        assert!(!RomRaider::detect("%DataLog%\nDataLogVersion : 1.1"));
    }

    #[test]
    fn test_parse_romraider_log() {
        let sample = "Time (msec),Engine Speed (rpm),Engine Load (%),A/F Correction #1 (%)\n\
                      0,1000,10.5,1.5\n\
                      20,1050,11.0,1.8\n\
                      40,1100,12.0,2.0\n";

        let parser = RomRaider;
        let log = parser.parse(sample).unwrap();

        assert_eq!(log.channels.len(), 3);
        assert_eq!(log.channels[0].name(), "Engine Speed");
        assert_eq!(log.channels[1].name(), "Engine Load");
        assert_eq!(log.channels[2].name(), "A/F Correction #1");

        assert_eq!(log.times.len(), 3);
        assert_eq!(log.data.len(), 3);

        // Check relative timestamps (converted from ms to seconds)
        assert!((log.times[0] - 0.0).abs() < 0.001);
        assert!((log.times[1] - 0.020).abs() < 0.001);
        assert!((log.times[2] - 0.040).abs() < 0.001);

        // Check first row values
        assert_eq!(log.data[0][0].as_f64(), 1000.0);
        assert_eq!(log.data[0][1].as_f64(), 10.5);
        assert_eq!(log.data[0][2].as_f64(), 1.5);

        // Check units
        assert_eq!(log.channels[0].unit(), "rpm");
        assert_eq!(log.channels[1].unit(), "%");
        assert_eq!(log.channels[2].unit(), "%");
    }

    #[test]
    fn test_parse_time_ms() {
        assert_eq!(RomRaider::parse_time_ms("0"), Some(0.0));
        assert_eq!(RomRaider::parse_time_ms("1000"), Some(1.0));
        assert_eq!(RomRaider::parse_time_ms("500"), Some(0.5));
        assert_eq!(RomRaider::parse_time_ms("invalid"), None);
    }

    #[test]
    fn test_parse_with_missing_values() {
        let sample = "Time (msec),RPM,Load\n\
                      0,1000,50\n\
                      20,1050,\n\
                      40,,60\n";

        let parser = RomRaider;
        let log = parser.parse(sample).unwrap();

        assert_eq!(log.data.len(), 3);

        // Empty values should be 0
        assert_eq!(log.data[1][1].as_f64(), 0.0); // Missing Load
        assert_eq!(log.data[2][0].as_f64(), 0.0); // Missing RPM
    }
}
