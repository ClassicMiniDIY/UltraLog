//! RomRaider log file parser.
//!
//! Parses CSV log files generated by RomRaider ECU logging software,
//! commonly used for Subaru ECUs. Supports both comma-delimited (US locale)
//! and semicolon-delimited (European locale) CSV formats.
//!
//! European locale files use semicolon as delimiter and comma as decimal
//! separator (e.g., "14,00" instead of "14.00").
//!
//! Reference: <https://github.com/RomRaider/RomRaider>

use serde::Serialize;
use std::error::Error;

use super::types::{Channel, Log, Meta, Parseable, Value};

/// RomRaider log file metadata
#[derive(Clone, Debug, Default, Serialize)]
pub struct RomRaiderMeta {
    /// Number of channels in the log
    pub channel_count: usize,
    /// Number of data points
    pub data_points: usize,
}

/// RomRaider channel definition
#[derive(Clone, Debug, Default, Serialize)]
pub struct RomRaiderChannel {
    /// Full column name from header (e.g., "Engine Speed (rpm)")
    pub name: String,
    /// Extracted unit from parentheses (e.g., "rpm")
    pub unit: String,
}

impl RomRaiderChannel {
    /// Create a new channel from a header column name
    /// Parses names like "Engine Speed (rpm)" into name and unit
    pub fn from_header(header: &str) -> Self {
        let header = header.trim().to_string();

        // Try to extract unit from parentheses at end
        // Format: "Channel Name (unit)" or "Channel Name"
        let (name, unit) = if let Some(paren_start) = header.rfind('(') {
            if let Some(paren_end) = header.rfind(')') {
                if paren_end > paren_start {
                    let unit = header[paren_start + 1..paren_end].trim().to_string();
                    let name = header[..paren_start].trim().to_string();
                    (name, unit)
                } else {
                    (header.clone(), Self::infer_unit(&header))
                }
            } else {
                (header.clone(), Self::infer_unit(&header))
            }
        } else {
            (header.clone(), Self::infer_unit(&header))
        };

        Self { name, unit }
    }

    /// Infer unit based on channel name when not explicitly provided
    fn infer_unit(name: &str) -> String {
        let name_lower = name.to_lowercase();

        // Temperature channels
        if name_lower.contains("temp") || name_lower.contains("iat") || name_lower.contains("ect") {
            return "°C".to_string();
        }

        // Pressure channels
        if name_lower.contains("pressure")
            || name_lower.contains("map")
            || name_lower.contains("baro")
            || name_lower.contains("boost")
        {
            return "psi".to_string();
        }

        // RPM channels
        if name_lower.contains("rpm") || name_lower.contains("engine speed") {
            return "rpm".to_string();
        }

        // Throttle/TPS channels
        if name_lower.contains("tps") || name_lower.contains("throttle") {
            return "%".to_string();
        }

        // Percentage channels
        if name_lower.contains("duty")
            || name_lower.contains("correction")
            || name_lower.contains("learning")
            || name_lower.contains("load")
        {
            return "%".to_string();
        }

        // Timing/angle channels
        if name_lower.contains("timing")
            || name_lower.contains("angle")
            || name_lower.contains("knock")
            || name_lower.contains("degrees")
        {
            return "°".to_string();
        }

        // Voltage channels
        if name_lower.contains("voltage") || name_lower.contains("battery") {
            return "V".to_string();
        }

        // AFR/Lambda channels
        if name_lower.contains("afr") || name_lower.contains("a/f") {
            return "AFR".to_string();
        }

        // Speed channels
        if name_lower.contains("speed") && !name_lower.contains("rpm") {
            return "mph".to_string();
        }

        // Mass airflow
        if name_lower.contains("maf") || name_lower.contains("mass airflow") {
            return "g/s".to_string();
        }

        // IAM (Ignition Advance Multiplier) - Subaru specific
        if name_lower == "iam" {
            return "".to_string();
        }

        // Default: no unit
        "".to_string()
    }

    /// Get the display unit for this channel
    pub fn unit(&self) -> &str {
        &self.unit
    }
}

/// RomRaider log file parser
pub struct RomRaider;

/// Delimiter type detected for the file
#[derive(Clone, Copy, Debug, PartialEq)]
enum Delimiter {
    Comma,
    Semicolon,
}

impl RomRaider {
    /// Detect if file contents look like a RomRaider log
    /// RomRaider logs start with "Time" and use either comma (US) or semicolon (European) delimiter
    pub fn detect(contents: &str) -> bool {
        if let Some(first_line) = contents.lines().next() {
            let first_line_lower = first_line.to_lowercase();

            // RomRaider logs typically start with Time column
            // Common patterns: "Time", "Time (msec)", "Time(ms)", etc.
            if first_line_lower.starts_with("time") {
                // Haltech uses "%DataLog%" marker - exclude it
                if contents.starts_with("%DataLog%") {
                    return false;
                }

                // ECUMaster uses "TIME;" or "TIME\t" (uppercase, no units in parentheses)
                // RomRaider uses "Time (msec)" with units in parentheses
                // Reject uppercase TIME with semicolon/tab - that's ECUMaster format
                if first_line.starts_with("TIME;") || first_line.starts_with("TIME\t") {
                    return false;
                }

                // Must have either comma or semicolon as delimiter
                let has_comma = first_line.contains(',');
                let has_semicolon = first_line.contains(';');

                // Accept if we have at least one delimiter type
                // Semicolon-delimited files (European locale) will have commas in decimal values
                // but semicolons as field separators
                return has_comma || has_semicolon;
            }
        }
        false
    }

    /// Detect the delimiter used in the file
    fn detect_delimiter(first_line: &str) -> Delimiter {
        // Count semicolons and commas in the header
        let semicolons = first_line.matches(';').count();
        let commas = first_line.matches(',').count();

        // If there are more semicolons than commas, it's semicolon-delimited
        // (European locale uses commas for decimals, not delimiters)
        if semicolons > commas {
            Delimiter::Semicolon
        } else if semicolons > 0 && commas > 0 {
            // Both present - check if commas appear within parentheses (units)
            // or if they're actual delimiters
            // For header line, commas in unit specs like "(rpm)" don't exist
            // So if we have semicolons in header, it's the delimiter
            if semicolons >= 2 {
                Delimiter::Semicolon
            } else {
                Delimiter::Comma
            }
        } else {
            Delimiter::Comma
        }
    }

    /// Parse a numeric value, handling European decimal format (comma as decimal separator)
    fn parse_european_number(value: &str, delimiter: Delimiter) -> Option<f64> {
        let value = value.trim();
        if value.is_empty() {
            return None;
        }

        // If using semicolon delimiter (European locale), convert comma to period
        let normalized = if delimiter == Delimiter::Semicolon {
            value.replace(',', ".")
        } else {
            value.to_string()
        };

        normalized.parse::<f64>().ok()
    }

    /// Parse time value from milliseconds string to seconds
    fn parse_time_ms(time_str: &str, delimiter: Delimiter) -> Option<f64> {
        Self::parse_european_number(time_str, delimiter).map(|ms| ms / 1000.0)
    }
}

impl Parseable for RomRaider {
    fn parse(&self, file_contents: &str) -> Result<Log, Box<dyn Error>> {
        // Pre-allocate based on estimated row count (first line is header)
        let line_count = file_contents.lines().count();
        let estimated_data_rows = line_count.saturating_sub(1);

        let mut channels: Vec<Channel> = Vec::with_capacity(50);
        let mut times: Vec<f64> = Vec::with_capacity(estimated_data_rows);
        let mut data: Vec<Vec<Value>> = Vec::with_capacity(estimated_data_rows);

        let mut lines = file_contents.lines();

        // Parse header line to get channel names
        let header = lines.next().ok_or("Empty file: no header found")?;

        // Detect delimiter (comma for US locale, semicolon for European locale)
        let delimiter = Self::detect_delimiter(header);
        let delimiter_char = match delimiter {
            Delimiter::Comma => ',',
            Delimiter::Semicolon => ';',
        };

        let column_names: Vec<&str> = header.split(delimiter_char).collect();

        if column_names.is_empty() {
            return Err("Invalid RomRaider log: no columns found".into());
        }

        // First column should be Time
        let first_col = column_names[0].trim().to_lowercase();
        if !first_col.starts_with("time") {
            return Err("Invalid RomRaider log: first column must be Time".into());
        }

        // Create channels from header (skip Time column)
        for name in column_names.iter().skip(1) {
            let channel = RomRaiderChannel::from_header(name);
            channels.push(Channel::RomRaider(channel));
        }

        // Track first timestamp for relative time calculation
        let mut first_time: Option<f64> = None;

        // Parse data rows
        for line in lines {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            let parts: Vec<&str> = line.split(delimiter_char).collect();
            if parts.is_empty() {
                continue;
            }

            // First column is time (in milliseconds)
            let time_str = parts[0].trim();
            if let Some(time_secs) = Self::parse_time_ms(time_str, delimiter) {
                // Calculate relative time from first record
                let relative_time = if let Some(first) = first_time {
                    time_secs - first
                } else {
                    first_time = Some(time_secs);
                    0.0
                };

                times.push(relative_time);

                // Parse remaining values
                let mut row_values: Vec<Value> = Vec::with_capacity(channels.len());

                for part in parts.iter().skip(1) {
                    if let Some(val) = Self::parse_european_number(part, delimiter) {
                        row_values.push(Value::Float(val));
                    } else {
                        // Empty or non-numeric value - use 0
                        row_values.push(Value::Float(0.0));
                    }
                }

                // Pad row to match channel count if needed
                while row_values.len() < channels.len() {
                    row_values.push(Value::Float(0.0));
                }

                data.push(row_values);
            }
        }

        tracing::info!(
            "Parsed RomRaider log ({:?} delimiter): {} channels, {} data points",
            delimiter,
            channels.len(),
            data.len()
        );

        Ok(Log {
            meta: Meta::RomRaider(RomRaiderMeta {
                channel_count: channels.len(),
                data_points: data.len(),
            }),
            channels,
            times,
            data,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_channel_from_header() {
        let ch = RomRaiderChannel::from_header("Engine Speed (rpm)");
        assert_eq!(ch.name, "Engine Speed");
        assert_eq!(ch.unit, "rpm");

        let ch = RomRaiderChannel::from_header("A/F Correction #1 (%)");
        assert_eq!(ch.name, "A/F Correction #1");
        assert_eq!(ch.unit, "%");

        let ch = RomRaiderChannel::from_header("IAM");
        assert_eq!(ch.name, "IAM");
        assert_eq!(ch.unit, "");

        let ch = RomRaiderChannel::from_header("Manifold Relative Pressure (psi)");
        assert_eq!(ch.name, "Manifold Relative Pressure");
        assert_eq!(ch.unit, "psi");
    }

    #[test]
    fn test_unit_inference() {
        assert_eq!(RomRaiderChannel::infer_unit("Coolant Temp"), "°C");
        assert_eq!(RomRaiderChannel::infer_unit("Engine Speed"), "rpm");
        assert_eq!(RomRaiderChannel::infer_unit("Throttle Opening Angle"), "%");
        assert_eq!(RomRaiderChannel::infer_unit("Battery Voltage"), "V");
        assert_eq!(RomRaiderChannel::infer_unit("A/F Sensor #1"), "AFR");
        assert_eq!(RomRaiderChannel::infer_unit("Mass Airflow"), "g/s");
    }

    #[test]
    fn test_detect_romraider() {
        // Should detect RomRaider format (US locale - comma delimiter)
        assert!(RomRaider::detect(
            "Time (msec),Engine Speed (rpm),Engine Load (%)\n0,1000,50"
        ));
        assert!(RomRaider::detect("Time,RPM,Load\n0,1000,50"));

        // Should detect RomRaider format (European locale - semicolon delimiter)
        assert!(RomRaider::detect(
            "Time (msec);Timing Advance (degrees);PLX Engine Speed (rpm)\n0;14,00;860"
        ));

        // Should not detect ECUMaster (uppercase TIME with path-style channels)
        assert!(!RomRaider::detect(
            "TIME;engine/rpm;sensors/tps\n0.000;1000;50"
        ));

        // Should not detect Haltech
        assert!(!RomRaider::detect("%DataLog%\nDataLogVersion : 1.1"));
    }

    #[test]
    fn test_detect_delimiter() {
        // Comma delimiter (US locale)
        assert_eq!(
            RomRaider::detect_delimiter("Time (msec),Engine Speed (rpm),Load (%)"),
            Delimiter::Comma
        );

        // Semicolon delimiter (European locale)
        assert_eq!(
            RomRaider::detect_delimiter(
                "Time (msec);Timing Advance (degrees);PLX Engine Speed (rpm)"
            ),
            Delimiter::Semicolon
        );
    }

    #[test]
    fn test_parse_european_number() {
        // US locale (comma delimiter, period decimal)
        assert_eq!(
            RomRaider::parse_european_number("10.5", Delimiter::Comma),
            Some(10.5)
        );

        // European locale (semicolon delimiter, comma decimal)
        assert_eq!(
            RomRaider::parse_european_number("14,00", Delimiter::Semicolon),
            Some(14.0)
        );
        assert_eq!(
            RomRaider::parse_european_number("0,38", Delimiter::Semicolon),
            Some(0.38)
        );

        // Empty values
        assert_eq!(RomRaider::parse_european_number("", Delimiter::Comma), None);
        assert_eq!(
            RomRaider::parse_european_number("  ", Delimiter::Semicolon),
            None
        );
    }

    #[test]
    fn test_parse_romraider_log() {
        let sample = "Time (msec),Engine Speed (rpm),Engine Load (%),A/F Correction #1 (%)\n\
                      0,1000,10.5,1.5\n\
                      20,1050,11.0,1.8\n\
                      40,1100,12.0,2.0\n";

        let parser = RomRaider;
        let log = parser.parse(sample).unwrap();

        assert_eq!(log.channels.len(), 3);
        assert_eq!(log.channels[0].name(), "Engine Speed");
        assert_eq!(log.channels[1].name(), "Engine Load");
        assert_eq!(log.channels[2].name(), "A/F Correction #1");

        assert_eq!(log.times.len(), 3);
        assert_eq!(log.data.len(), 3);

        // Check relative timestamps (converted from ms to seconds)
        assert!((log.times[0] - 0.0).abs() < 0.001);
        assert!((log.times[1] - 0.020).abs() < 0.001);
        assert!((log.times[2] - 0.040).abs() < 0.001);

        // Check first row values
        assert_eq!(log.data[0][0].as_f64(), 1000.0);
        assert_eq!(log.data[0][1].as_f64(), 10.5);
        assert_eq!(log.data[0][2].as_f64(), 1.5);

        // Check units
        assert_eq!(log.channels[0].unit(), "rpm");
        assert_eq!(log.channels[1].unit(), "%");
        assert_eq!(log.channels[2].unit(), "%");
    }

    #[test]
    fn test_parse_romraider_european_locale() {
        // European locale: semicolon delimiter, comma decimal separator
        let sample = "Time (msec);Timing Advance (degrees);PLX Engine Speed (rpm);PLX Manifold Absolute Pressure (bar)\n\
                      0;14,00;860;0,38\n\
                      198;12,00;841;0,37\n\
                      396;14,00;860;0,37\n";

        let parser = RomRaider;
        let log = parser.parse(sample).unwrap();

        assert_eq!(log.channels.len(), 3);
        assert_eq!(log.channels[0].name(), "Timing Advance");
        assert_eq!(log.channels[1].name(), "PLX Engine Speed");
        assert_eq!(log.channels[2].name(), "PLX Manifold Absolute Pressure");

        assert_eq!(log.times.len(), 3);
        assert_eq!(log.data.len(), 3);

        // Check relative timestamps (converted from ms to seconds)
        assert!((log.times[0] - 0.0).abs() < 0.001);
        assert!((log.times[1] - 0.198).abs() < 0.001);
        assert!((log.times[2] - 0.396).abs() < 0.001);

        // Check first row values (European decimals converted)
        assert_eq!(log.data[0][0].as_f64(), 14.0);
        assert_eq!(log.data[0][1].as_f64(), 860.0);
        assert!((log.data[0][2].as_f64() - 0.38).abs() < 0.001);

        // Check units (extracted from parentheses in header)
        assert_eq!(log.channels[0].unit(), "degrees");
        assert_eq!(log.channels[1].unit(), "rpm");
        assert_eq!(log.channels[2].unit(), "bar");
    }

    #[test]
    fn test_parse_time_ms() {
        // US locale
        assert_eq!(RomRaider::parse_time_ms("0", Delimiter::Comma), Some(0.0));
        assert_eq!(
            RomRaider::parse_time_ms("1000", Delimiter::Comma),
            Some(1.0)
        );
        assert_eq!(RomRaider::parse_time_ms("500", Delimiter::Comma), Some(0.5));
        assert_eq!(RomRaider::parse_time_ms("invalid", Delimiter::Comma), None);

        // European locale
        assert_eq!(
            RomRaider::parse_time_ms("0", Delimiter::Semicolon),
            Some(0.0)
        );
        assert_eq!(
            RomRaider::parse_time_ms("1000", Delimiter::Semicolon),
            Some(1.0)
        );
    }

    #[test]
    fn test_parse_with_missing_values() {
        let sample = "Time (msec),RPM,Load\n\
                      0,1000,50\n\
                      20,1050,\n\
                      40,,60\n";

        let parser = RomRaider;
        let log = parser.parse(sample).unwrap();

        assert_eq!(log.data.len(), 3);

        // Empty values should be 0
        assert_eq!(log.data[1][1].as_f64(), 0.0); // Missing Load
        assert_eq!(log.data[2][0].as_f64(), 0.0); // Missing RPM
    }
}
